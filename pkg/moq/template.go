package moq

// moqImports are the imports all moq files get.
var moqImports = []string{}

// moqTemplate is the template for mocked code.
var moqTemplate = `// Code generated by moq; DO NOT EDIT.
// github.com/blyork/moq

package {{.PackageName}}
{{- $sourcePackagePrefix := .SourcePackagePrefix}}

import (
{{- range .Imports }}
	"{{.}}"
{{- end }}
)

{{ range $i, $obj := .Objects -}}
// Ensure, that {{.InterfaceName}}Mock does implement {{.InterfaceName}}.
// If this is not the case, regenerate this file with moq.
var _ {{$sourcePackagePrefix}}{{.InterfaceName}} = &{{.InterfaceName}}Mock{}

// {{.InterfaceName}}Mock is a mock implementation of {{.InterfaceName}}.
//
//     func TestSomethingThatUses{{.InterfaceName}}(t *testing.T) {
//
//         // make and configure a mocked {{.InterfaceName}}
//         mocked{{.InterfaceName}} := &{{.InterfaceName}}Mock{ {{ range .Methods }}
//             {{.Name}}Func: func({{ .Arglist }}) {{.ReturnArglist}} {
// 	               panic("moqInstance out the {{.Name}} method")
//             },{{- end }}
//         }
//
//         // use mocked{{.InterfaceName}} in code that requires {{.InterfaceName}}
//         // and then make assertions.
//
//     }
type {{.InterfaceName}}Mock struct {
{{- range .Methods }}
	// {{.Name}}Func mocks the {{.Name}} method.
	{{.Name}}Func func({{ .Arglist }}) {{.ReturnArglist}}
{{ end }}
	// calls tracks calls to the methods.
	calls struct {
{{- range .Methods }}
		// {{ .Name }} holds details about calls to the {{.Name}} method.
		{{ .Name }} struct {
			Calls []{{$obj.InterfaceName}}Mock{{.Name}}Call
			Mu sync.RWMutex
		}
{{- end }}
	}
}

{{ range .Methods -}}
// {{.Name}} calls {{.Name}}Func.
func (moqInstance *{{$obj.InterfaceName}}Mock) {{.Name}}({{.Arglist}}) {{.ReturnArglist}} {
	if moqInstance.{{.Name}}Func == nil {
		panic("{{$obj.InterfaceName}}Mock.{{.Name}}Func: method is nil but {{$obj.InterfaceName}}.{{.Name}} was just called")
	}
    var moqCallIndex int
	moqInstance.calls.{{.Name}}.Mu.Lock()
	moqCallIndex = len(moqInstance.calls.{{.Name}}.Calls)
    moqInstance.calls.{{.Name}}.Calls = append(moqInstance.calls.{{.Name}}.Calls, {{$obj.InterfaceName}}Mock{{.Name}}Call{
		In: {{$obj.InterfaceName}}Mock{{.Name}}CallInput{
			{{- range .Params }}
			{{ .Name | Exported }}: {{ .Name }},
			{{- end }}
        },
	})
	moqInstance.calls.{{.Name}}.Mu.Unlock()

{{- if .ReturnArglist }}
	{{.ReturnArgCallList}} := moqInstance.{{.Name}}Func({{.ArgCallList}})
	moqInstance.calls.{{.Name}}.Mu.Lock()
	moqInstance.calls.{{.Name}}.Calls[moqCallIndex].Out = {{$obj.InterfaceName}}Mock{{.Name}}CallOutput{
		{{- range .Returns }}
		{{ .Name | Exported }}: {{ .Name }},
		{{- end }}
	} 
	moqInstance.calls.{{.Name}}.Mu.Unlock()
{{- else }}
	moqInstance.{{.Name}}Func({{.ArgCallList}})
{{- end }}
}

// {{$obj.InterfaceName}}Mock{{.Name}}CallInput represents the input to a {{$obj.InterfaceName}}Mock.{{.Name}} call.
type {{$obj.InterfaceName}}Mock{{.Name}}CallInput struct {
  {{- range .Params }}
  {{ .Name | Exported }} {{ .Type }}
  {{- end }}
}

// {{$obj.InterfaceName}}Mock{{.Name}}CallOutput represents the output for a {{$obj.InterfaceName}}Mock.{{.Name}} call.
type {{$obj.InterfaceName}}Mock{{.Name}}CallOutput struct {
  {{- range .Returns }}
  {{ .Name | Exported }} {{ .Type }}
  {{- end }}
}

// {{$obj.InterfaceName}}Mock{{.Name}}Call represents the input and output for a {{$obj.InterfaceName}}Mock.{{.Name}} call.
type {{$obj.InterfaceName}}Mock{{.Name}}Call struct {
  In {{$obj.InterfaceName}}Mock{{.Name}}CallInput
  Out {{$obj.InterfaceName}}Mock{{.Name}}CallOutput
}

// {{.Name}}Calls gets all the calls that were made to {{.Name}}.
// Check the length with:
//     len(mocked{{$obj.InterfaceName}}.{{.Name}}Calls())
func (moqInstance *{{$obj.InterfaceName}}Mock) {{.Name}}Calls() []{{$obj.InterfaceName}}Mock{{.Name}}Call {
	var calls []{{$obj.InterfaceName}}Mock{{.Name}}Call
	moqInstance.calls.{{.Name}}.Mu.RLock()
	calls = moqInstance.calls.{{.Name}}.Calls
	moqInstance.calls.{{.Name}}.Mu.RUnlock()
	return calls
}
{{ end -}}
{{ end -}}`
